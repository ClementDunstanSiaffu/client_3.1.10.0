import { IGeometry, GeometryType, IFeature, IPopupInfo, IItem, SpatialRelationship, Units, IFeatureLayer, ILayerDefinition } from '@esri/arcgis-rest-types'
import { IAttachmentInfo } from '@esri/arcgis-rest-feature-layer'
// only used as types
import { DataSourceManager, IMDataSourceJson, IMDataSourceSchema, IMReversedDataSourceSchema, IntlShape, IMDataSourceInfo, ServiceDefinition, ImmutableObject, ImmutableArray } from 'jimu-core'
// only used as types
import { WebMapWebChart } from 'arcgis-charts'

/**
 * All data source status is here, including data source instance status and data status (for QueriableDataSource).
 * * Instance status includes: NotCreated, Created, CreateError. <br/>
 *    When a data source is requested to be created, it is set to `NotCreated` at first.
 *    If a data source has never been used, there is no data source status.
 * * Data status includes: NotReady, Unloaded, Loading, Loaded, LoadError. <br/>
 *    When a QueriableDataSource is created, it is set as `NotReady` or `Unloaded` at first.
 *    If the data source is generated by widgets, the initial status will be `NotReady`, otherwise the initial status will be `Unloaded`.
 *    When widgets are ready to generate data, that is to say, the data source is ready to do query, widgets will change the status from `NotReady` to `Unloaded`.
 *    When widgets are not ready to generate data, widgets will change the status back to `NotReady`,
 *    then framework will help to clear source records, records and cache in data source instance.
 *    If `load()` is invoked, it will be set as `Loading`. If data is returned, it will be set as `Loaded`.
 *    If an error occurs, it will be set as `LoadError`.
 */
export enum DataSourceStatus {
  // Instance status.
  NotCreated = 'NOT_CREATED',
  Created = 'CREATED',
  CreateError = 'CREATE_ERROR',

  // Data status.
  /**
   * NotReady is for widget output data source only.
   * When output data source instance is created, the data is not ready for use.
   * Widget should dispatch an action (DataSourceStatusChanged) to make the data source ready for use.
   * If a data source status is not ready, the query should return an empty result.
   */
  NotReady = 'NOT_READY',
  Unloaded = 'UNLOADED',
  Loading = 'LOADING',
  Loaded = 'LOADED',
  LoadError = 'LOAD_ERROR',

  // Save status.
  /** @ignore */
  Saving = 'SAVING',
  /** @ignore */
  Saved = 'SAVED',
  /** @ignore */
  SaveError = 'SAVE_ERROR',

  // For remote push(stream) data sources.
  /** @ignore */
  Closed = 'CLOSED',
  /** @ignore */
  Connecting = 'CONNECTING',
  /** @ignore */
  Connected = 'CONNECTED',
  /** @ignore */
  Closing = 'CLOSING',

  // For client DS, we don't define status.
}

/**
 * The data source types that `jimu-core` supports.
 */
export enum DataSourceTypes {
  /** @ignore */
  SimpleLocal = 'SIMPLE_LOCAL',
  /** @ignore */
  CSV = 'CSV',

  /**
   * FeatureLayer data source is a `QueriableDataSource`, which is used to query ArcGIS feature service.
   * See {@link FeatureLayerDataSource}
   */
  FeatureLayer = 'FEATURE_LAYER',
  /**
   * See {@link SceneLayerDataSource}
   */
  SceneLayer = 'SCENE_LAYER',
  /**
   * GroupLayer data source is a data source set that may have child data sources. It is from group layer in a map service or a webmap/webscene.
   */
  GroupLayer = 'GROUP_LAYER',
  /**
   * FeatureService data source is a data source set that may have child data sources. It is from the feature service.
   */
  FeatureService = 'FEATURE_SERVICE',
  /**
   * MapService data source is a data source set that may have child data sources. It is from the map service.
   */
  MapService = 'MAP_SERVICE',
  /**
   * SceneService data source is a data source set that may have child data sources. It is from the scene service.
   */
  SceneService = 'SCENE_SERVICE'
}

/**
 * @ignore
 */
export enum ArcGISDataSourceTypes {
  Map = 'MAP',
  WebMap = 'WEB_MAP',
  WebScene = 'WEB_SCENE',
}

/**
 * @ignore
 * All data source types, including types from jimu-core and jimu-arcgis.
 * The variable is only used as `value`, e.g. const types = [AllDataSourceTypes.WebMap].
 */
export const AllDataSourceTypes = { ...DataSourceTypes, ...ArcGISDataSourceTypes }

/**
* All data source types, including types from jimu-core and jimu-arcgis.
* The variable is only used as `type`, e.g. let types: AllDataSourceTypes[].
*/
// eslint-disable-next-line
 export type AllDataSourceTypes = DataSourceTypes | ArcGISDataSourceTypes

/**
 * For now, we only support some layer service types.
 */
export enum SupportedLayerServiceTypes {
  // single layer service under map service or feature service
  FeatureLayer = 'Feature Layer',
  Table = 'Table',
  GroupLayer = 'Group Layer',

  // single layer service under scene service
  SceneLayerPoint = 'Point',
  SceneLayer3DObject = '3DObject'
}

/**
 * For now, we only support some service types.
 */
export enum SupportedServiceTypes {
  // [Feature Service](https://developers.arcgis.com/rest/services-reference/feature-service.htm)
  FeatureService = 'FeatureServer',
  // [Map Service](https://developers.arcgis.com/rest/services-reference/hosted-map-service.htm)
  MapService = 'MapServer',
  // [Scene Service](https://developers.arcgis.com/rest/services-reference/scene-service.htm)
  SceneService = 'SceneServer'
}

/**
 * For now, we only support some portal item types.
 * Please see [Items and item types](https://developers.arcgis.com/rest/users-groups-and-items/items-and-item-types.htm).
 */
export enum SupportedItemTypes {
  WebMap = 'Web Map',
  WebScene = 'Web Scene',
  FeatureService = 'Feature Service',
  MapService = 'Map Service',
  SceneService = 'Scene Service',
  FeatureCollection = 'Feature Collection',
  GeometryService = 'Geometry Service',
  GeocodingService = 'Geocoding Service',
  GeoprocessingService = 'Geoprocessing Service',
  NetworkAnalysisService = 'Network Analysis Service',
  GeoenrichmentService = 'Geoenrichment service'
}

/**
 * For now, we only support some layer types.
 * Please see [Layer](https://developers.arcgis.com/javascript/latest/api-reference/esri-layers-Layer.html).
 */
export enum SupportedLayerTypes {
  FeatureLayer = 'feature',
  MapImageLayer = 'map-image',
  TileLayer = 'tile',
  GroupLayer = 'group',
  SceneLayer = 'scene'
}

/**
 * Data source factory is used to create data source.
 */
export interface DataSourceFactory {
  createDataSource: (options: DataSourceConstructorOptions) => DataSource
}

/** @ignore */
export interface AttachmentInfo extends IAttachmentInfo {
  url?: string
}

/** @ignore */
export interface AttachmentQueryOptions {
  attachmentTypes: string[]
  url: string
  featureId: number | string
}

/**
 * Parameters of `DataSource`'s constructor.
 */
export interface DataSourceConstructorOptions {
  /** The data source ID. */
  id: string

  /**
   * dataSourceJson or belongToDataSource is either-or option.
   * Pass dataSourceJson will create a main data source.
   * Pass belongToDataSource will create data view or local data source.
   */
  dataSourceJson?: IMDataSourceJson

  /** Data source that the to-be-created data source belongs to. */
  belongToDataSource?: DataSource

  /**
   * If dataViewId exists, a data view will be created.
   */
  dataViewId?: string

  /**
   * if localId exists, a local data source will be created.
   */
  localId?: string

  dataSourceManager?: DataSourceManager
  parentDataSource?: DataSource
  jimuChildId?: string
  /**
  * If all of the data is holded in the data source instance, put the data in the source records.
  * For others, the data may come from AGOL/portal item or a remote database.
  *
  * Only main data source or selection view will save source records,
  * if current data source is a view of selection view, will use selection view's source records, else,
  * will use main data source's source records.
  */
  sourceRecords?: DataRecord[]
  /**
   * Order in the parent data source.
   */
  order?: number
}

/**
 * @ignore
 */
export class DataSourceError extends Error {
  dataSourceId: string
  constructor (id, message) {
    super(message)
    this.dataSourceId = id
  }
}

// #region Data records

/**
 * A data record represents a record in a data source.
 */
export interface DataRecord {
  /** A reference of the data source object that has this record. */
  dataSource: DataSource

  /**
   * The data is a plain object. The format is {key: value}, and the key is "jimuFieldName".
   *
   * The data before mapping use this schema: {fieldName: value}. We need to return this schema: {jimuFieldName: value}.
   */
  getData: () => any
  setData: (data) => void
  /**
   * Create a clone of the data record object.
   * Use shallow clone by default. If `deep` is `true`, will use deep clone.
   */
  clone: (deep?: boolean) => DataRecord

  /** @ignore */
  getDataBeforeMapping: () => any
  /**
   * Return formatted record.
   */
  getFormattedData: (intl: IntlShape) => any
  /**
   * Return the value of a specific field.
   */
  getFieldValue: (jimuFieldName: string) => any
  /**
   * Return the formatted value of a specific field.
   */
  getFormattedFieldValue: (jimuFieldName: string, intl: IntlShape) => string
  /** @ignore */
  convertBeforeMappingDataToData: (beforeMappingData: any) => any
  /**
   * Return the data in JSON format, which is used to serialize data, and the key is "jimuFieldName".
   */
  toJson: () => any
  /**
   * Return ID of the record.
   */
  getId: () => string
  /**
   * Set ID of the record.
   */
  setId: (id: string) => void
  /**
   * Return geometry of the record.
   */
  getGeometry: () => IGeometry
  setGeometry: (geo: IGeometry) => void
}

/**
 * Record of feature layer data source.
 */
export interface FeatureDataRecord extends DataRecord {
  /** The feature returned from query REST API or the ArcGIS JS API [Graphic](https://developers.arcgis.com/javascript/latest/api-reference/esri-Graphic.html) object */
  feature: IFeature | __esri.Graphic
  dataSource: FeatureLayerDataSource | SceneLayerDataSource
  attachmentInfos: AttachmentInfo[]
  clone: (deep?: boolean) => FeatureDataRecord
  queryAttachments: (attachmentTypes?: string[]) => Promise<AttachmentInfo[]>
  fetchSymbolPreviewHTML: () => Promise<HTMLElement>
  getData: () => { [key: string]: any }
  getFormattedFieldValue: (jimuFieldName: string, intl: IntlShape) => string
  getDataBeforeMapping: () => { [key: string]: any }
  getOriginData: () => { [key: string]: any }
  toJson: () => IFeature | __esri.Graphic
  getId: () => string
  setId: (id: string) => void
  getGeometry: () => IGeometry
  setFeature: (feature: IFeature | __esri.Graphic) => void
  getFeature: () => IFeature | __esri.Graphic
}

/**
 * A DataRecordSet has a collection of data records. Similar to [FeatureSet](https://developers.arcgis.com/javascript/latest/api-reference/esri-tasks-support-FeatureSet.html)
 */
export interface DataRecordSet {
  /** The records of the set */
  records: DataRecord[]
  /** The fields names */
  fields?: string[]

  /** The data source where the data record set comes from. */
  dataSource?: DataSource

  /** The name of the DataRecordSet */
  name?: string
}

// #endregion Data records

// #region Data queries

/**
 * The result of data source's query method.
 */
export interface QueryResult {
  /**
   * The query parameters that generate the result.
   */
  queryParams: IMQueryParams
  /**
   * Records of the query result.
   */
  records?: DataRecord[]
  /**
   * The jimuFieldName.
   */
  fields?: string[]
  /**
   * The number of result records.
   */
  count?: number
  /**
   * Source version of data source.
   * @ignore
   */
  sourceVersion?: number
}

/**
 * Query scope defines which data is returned when the query is executed in addition to the query parameters.
 */
export enum QueryScope {
  /** Use the query parameters directly to query. */
  InAllData = 'IN_ALL_DATA',

  /** Use the query parameters and the filters configured in exb to query. */
  InRemoteConfigView = 'IN_REMOTE_CONFIG_VIEW',

  /** Use the query parameters and the configured filters in data source and filters configured in exb to query. */
  InConfigView = 'IN_CONFIG_VIEW',

  /** Use all of the appliyed query parameters to query. */
  InRuntimeView = 'IN_RUNTIME_VIEW'
}

/**
 * Options when calling data source's load method.
 */
export interface QueryOptions {
  scope?: QueryScope

  /** For load only.
   *  For local data source, you can use local ID as widget ID.
   */
  widgetId?: string

  /** Force the query even if  the query parameters have not changed. */
  refresh?: boolean

  /**
   * When execute query, the matched query is excluded.
   * Valid in runtime scope only.
   */
  excludeQuery?: WidgetDataSourcePair
  /**
   * Whether the server is case-sensitive.
   */
  isCaseSensitive?: boolean
}

export interface GetCurrentQueryParamsOptions {
  exclude?: WidgetDataSourcePair
  /**
   * Whether the server is case-sensitive.
   */
  isCaseSensitive?: boolean
}

export interface WidgetDataSourcePair {
  dataSourceId: string
  widgetId: string
}

/** The base query parameter interface. */
export interface QueryParams {
  /**
   * Page number starts from 1, not 0.
   */
  page?: number
  /**
   * Page size.
   */
  pageSize?: number
}
export type IMQueryParams = ImmutableObject<QueryParams>

/**
 * Query parameter which supports SQL.
 */
export interface SqlQueryParams extends QueryParams {
  /**
   * A where clause for the query.
   */
  where?: string
  /**
   * The list of fields to be included in the returned result set.
   */
  outFields?: string[]
  /**
   * One or more `jimuFieldName` by which the features/records will be ordered.
   * Use ASC for ascending and DESC for descending. The following fields are used to control the ordering.
   * orderByFields is set to ASC (ascending order) by default if <ORDER> is unspecified.
   */
  orderByFields?: string[]
  /**
   * One or more `jimuFieldName` by which the values will be grouped for calculating the statistics.
   */
  groupByFieldsForStatistics?: string[]
}
export type IMSqlQueryParams = ImmutableObject<SqlQueryParams>

/**
 * Query parameters for featuer layer.
 */
export interface FeatureLayerQueryParams extends SqlQueryParams {
  /**
   * Object IDs of records to be queried.
   */
  objectIds?: number[]
  /**
   * The geometry of the spatial filter.
   */
  geometry?: IGeometry
  geometryType?: GeometryType
  /**
   * The spatial relationship to be applied to the input geometry while performing the query.
   */
  spatialRel?: SpatialRelationship
  /**
   * The buffer distance for the input geometries.
   */
  distance?: number
  /**
   * The unit for calculating the buffer distance.
   */
  units?: Units
  /**
   * If true, the geometry of each result feature will be returned.
   */
  returnGeometry?: boolean
  /**
   * This option can be used to specify the number of decimal places for the returned geometries.
   */
  geometryPrecision?: number
  /**
   * The definitions for one or more field-based statistics to be calculated.
   */
  outStatistics?: StatisticDefinition[]
  /**
   * If true, z-values are included in the results if the features have z-values. Otherwise, z-values are not returned.
   */
  returnZ?: boolean
  /**
   * If true, m-values are included in the results if the features have m-values. Otherwise, m-values are not returned.
   */
  returnM?: boolean
  /**
   * Specify the geodatabase version to be queried.
   */
  gdbVersion?: string
  /**
   * The sqlFormat parameter can be either standard SQL-92 standard or it can use the native SQL of the underlying data store native.
   */
  sqlFormat?: 'none' | 'standard' | 'native'
  /**
   * If true, it returns distinct values based on the fields specified in outFields.
   */
  returnDistinctValues?: boolean
  /**
   * The time instant or the time extent to query. A null value specified for start time or end time will represent infinity for start or end time, respectively.
   */
  time?: TimeExtent
}
export type IMFeatureLayerQueryParams = ImmutableObject<FeatureLayerQueryParams>

/**
 * The definitions for one or more field-based statistics to be calculated.
 */
export interface StatisticDefinition {
  /**
   * Statistic type.
   */
  statisticType: 'count' | 'sum' | 'min' | 'max' | 'avg' | 'stddev' | 'var' | 'percentile_cont' | 'percentile_disc'
  /**
   * Field to execute statistic query.
   */
  onStatisticField: string
  /**
   * Name of statistic query result.
   */
  outStatisticFieldName: string
  /**
   * The parameters is for percentile statistics.
   */
  statisticParameters?: StatisticParameters
}

export interface StatisticParameters {
  /**
   * `value` should be a decimal value between 0 and 1.
   */
  value: number
  // `orderBy` in chart series query is lower case.
  orderBy?: 'ASC' | 'DESC' | 'asc' | 'desc'
}

/** @ignore */
export interface CodedValue {
  value: string | number
  label: string
  render?: (item: CodedValue) => any
}

export type TimeExtent = number | [number, number]

export interface TimeInfo {
  timeExtent: [number, number]
  startTimeField?: string
  endTimeField?: string
  trackIdField?: string
  timeReference?: TimeReference
  timeInterval?: number
  timeIntervalUnits?: 'esriTimeUnitsCenturies' | 'esriTimeUnitsDays' | 'esriTimeUnitsDecades' | 'esriTimeUnitsHours' | 'esriTimeUnitsMilliseconds' | 'esriTimeUnitsMinutes' | 'esriTimeUnitsMonths' | 'esriTimeUnitsSeconds' | 'esriTimeUnitsWeeks' | 'esriTimeUnitsYears' | 'esriTimeUnitsUnknown'
}

export interface TimeReference {
  respectsDaylightSaving?: boolean
  timeZone?: string
}

// #endregion Data queries

// #region Data sources

/**
 * The interface for all data sources.
 *
 * Conceptually, we have four types of data sources but all of them are created as data source object:
 * * Main data source: the data source user added in data panel.
 * * Data view: the data view user created in data panel.
 * * Local data source: when multiple widgets connnect to a main data source or a data view, they'll share the same data records. If you need to
 *    use a local data copy, you can create a local data source from a main data source by using `DataSourceManager.getInstance().createLocalDataSource()`.
 * * Local data view: a local data source created from a data view.
 *
 * Data view, local data source or local data view derived from the same main data source will share the same schema, same selection records, but may have different data records.
 * The schema is in main data source only.
 *
 * To share the selection between data source and view, we create a selection data view when creating the data source. The selection data source view ID is: `${dataSourceId}-selection`.
 * When selecting records, the selected records are copied to the selection data view.
 *
 */
export interface DataSource {

  // #region Basic interface

  /** The data source ID. */
  id: string

  /** The type of the data source */
  type: string

  /**
   * The data source JSON object in app config.
   */
  getDataSourceJson: () => IMDataSourceJson
  /** Update data source JSON in data source instance */
  setDataSourceJson: (dsJson: IMDataSourceJson) => void
  /** Return data source label. */
  getLabel: () => string

  /**
   * Return used fields both saved in config and load on demand.
   * @ignore
   */
  getAllUsedFields: () => string[] | '*'
  /**
   * Return used fields load on demand. For example, out fields in query params.
   * @ignore
   */
  getLoadOnDemandUsedFields: () => string[] | '*'
  /**
   * Return used fields saved in config. For example, fields saved in use data sources of widget config.
   * @ignore
   */
  getConfigUsedFields: () => string[] | '*'

  dataSourceManager: DataSourceManager

  /**
   * Whether a data source contains child data sources.
   * A dataset data source should create all its child data sources before `ready()` is resolved.
   */
  isDataSourceSet: boolean

  /**
   * True means the data source is a data view.
   * For local data source, this is false even the local data source is created from a data view.
   */
  isDataView: boolean

  /**
   * True means the data source is a local data source.
   */
  isLocal: boolean

  /** The local ID of the data source. */
  localId?: string

  /**
   * When current data source is created from an array of records, will save it in `sourceRecords`.
   * These two methods are use to update or get the source data.
   */
  setSourceRecords: (records: DataRecord[]) => void
  /** Return the source records */
  getSourceRecords: () => DataRecord[]

  /**
   * The data schema is in "dataSourceJson",
   *    * For data source, use "jimuName" as key, and save the actual field name in the object.
   *    * For data source set, use "jimuChildId" as key, and save the actual child ID in the object.
   * In many cases, we need to use the actual "childId" or "fieldName" to access info, so we can use this method to get a reverse schema for ease of use.
   */
  /** @ignore */
  getReversedConfigSchema: () => IMReversedDataSourceSchema
  /**
   * Builds a data record only -- does not add the record into data source.
   */
  buildRecord: (data: any) => DataRecord

  /** Get record by index */
  getRecord: (index: number) => DataRecord

  /** Get record by ID */
  getRecordById: (id: string) => DataRecord
  /** Get records */
  getRecords: () => DataRecord[]

  /**
   * Update the records in the data source object only, does not update the source data.
   * See {@link DataSourceEditSourceOperations.updateRecords}
   */
  setRecords: (records: DataRecord[]) => void
  nextRecord?: () => DataRecord
  prevRecord?: () => DataRecord

  /** The total records count depends on the current query */
  count?: number

  /**
   * This function will clear the loaded records and won't clear the sourceRecords. Once the loaded records are cleared, the version in the data source info will be updated.
   */
  clearRecords?: () => void
  /**
   * @ignore
   * Clear records but don't add version in data source info.
   */
  clearRecordsNotAddVersion?: () => void
  /**
   * Clear both sourceRecords and loaded records. Both source version and version in data source info will be updated.
   */
  clearSourceRecords: () => void
  /**
   * @ignore
   * Clear source records and records, neither source version nor version will be added.
   */
  clearSourceRecordsNotAddVersion: () => void

  /**
   * The schema returned here is the merged result of the configured schema and the fetched schema.
   */
  getSchema: () => IMDataSourceSchema
  setSchema: (schema: IMDataSourceSchema) => void

  /**
   * @ignore
   * The schema contains all fields defined in the actual service. You can select some of the fields and only allow widgets to use these fields.
   * Framework provide two ways to select fields, one is to change the app config in builder, the other is to call `dataSource.setSelectedFields` in app.
   *
   * The method will return the intersection of configured selected fields and runtime selected fields.
   * The fields of used data source in widget json should be a sub set of the returned selected fields.
   * For example, widgets can call `setSelectedFields` to limit the selectable fields of its output data source.
   */
  getSelectedFields: () => string[] // jimuName
  setSelectedFields: (jimuNames: string[]) => void

  /**
   * Fetch the data schema from an actual data source. If it's a statistic data source, the schema will not be fetched.
   */
  fetchSchema: () => Promise<IMDataSourceSchema>

  getFetchedSchema: () => IMDataSourceSchema
  setFetchedSchema: (schema: IMDataSourceSchema) => void
  /** Return data source status. */
  getStatus: () => DataSourceStatus
  /** Update data source status. */
  setStatus?: (status: DataSourceStatus) => void
  /** Return data source count status. */
  getCountStatus: () => DataSourceStatus
  /** Update data source count status. */
  setCountStatus?: (status: DataSourceStatus) => void
  /** Return data source version. */
  getVersion: () => number
  /** Update data source version. */
  addVersion?: () => void

  /**
   * When current data source is created from an array of records, it will be saved in `sourceRecords`.
   * Return the version of `sourceRecords`.
   */
  getSourceVersion: () => number
  /**
   * When current data source is created from an array of records, it will be saved in `sourceRecords`.
   * Add the version of `sourceRecords`.
   * `setSourceRecords` will add the version by default.
   */
  addSourceVersion: () => void
  /** Return the data source ID field. */
  getIdField: () => string

  destroy: () => void

  /**
   * Ready is resolved means the data source instance is ready for use.
   */
  /* eslint-disable-next-line */
  ready: () => Promise<void | any>
  /** Return the data source info in redux store. */
  getInfo: () => IMDataSourceInfo

  /**
   * Return null means the data source is a non-spatial data source.
   * @ignore
   */
  getGeometryType: () => GeometryType

  /**
   * For most of the widget output data source, it has an original data source from which it's generated.
   * For the configured data source, return null.
   * @ignore
   */
  getOriginDataSources?: () => DataSource[]

  /**
   * Return the derived data views and local data sources.
   */
  getAllDerivedDataSources: () => DataSource[]

  // #endregion

  // #region interface for parent data source
  /** Return child data sources of a parent data source. */
  getChildDataSources?: () => DataSource[]

  /** Return all child data sources of a parent data source, includes the grandchildren */
  getAllChildDataSources?: () => DataSource[]

  /**
   * Get child data source by `jimuChildId`. You can get `jimuChildId` by `getJimuChildId()`.
   */
  getChildDataSource?: (jimuChildId: string) => DataSource

  /**
   * Get the actual data source ID by `jimuChildId`.
   * @ignore
   */
  getChildDataSourceId?: (jimuChildId: string) => string

  /**
   * @ignore
   * The jimu child ID is similar to the jimuFieldName, and widgets should use the jimuChildId instead of the childId to make data mapping work.
   */
  getJimuChildId?: (childId: string) => string[]
  // #endregion

  // #region interface for child data source
  /**
   * The parent data source of this data source, mull means it's a root data source.
   */
  parentDataSource: DataSource

  jimuChildId: string
  /**
   * Order in the parent data source.
   */
  order?: number
  /** Return the root data source. */
  getRootDataSource: () => DataSource
  // #endregion

  // #region interface for data view or local data source
  /** The data source which this data source derives from. */
  belongToDataSource?: DataSource
  /** Return the main data source. */
  getMainDataSource: () => DataSource

  /** The data view ID configured in Json. */
  dataViewId?: string
  /** Return all data views created from a main data source. */
  getDataViews: () => DataSource[]
  /** Get data view by data view ID. */
  getDataView: (dataViewId: string) => DataSource

  /** Return all local data sources created from a main data source or data view. */
  getLocalDataSources: () => DataSource[]
  /** Get local data source by local ID. */
  getLocalDataSource: (localId: string) => DataSource
  /**
   * @ignore
   * Get whether a data source should use records of no_selection view as its own source records.
   */
  useNoSelectionView: (dataSource?: DataSource) => boolean
  // #endregion

  // #region interface for data source edit operations
  /**
   * @ignore
   * These methods will update the source data of data source.
   *
   * The data source object provides an interface interact with its source,
   * the source 1. may come from AGOL/portal item or a remote database, 2. may come from an array directly.
   * If the source comes from AGOL/portal item or a remote database, these operations will use JS API or REST API to apply edits to it.
   * If the source comes from an array directly, will save it in `sourceRecords` and these operations will edit the `sourceRecords`.
   *
   * The data source object also contains a subset of its source, the subset is saved in `records` and loaded from source.
   * To update the subset, please use `setRecords()`, to update the source, please use these operations.
   * To get the subset, please use `getRecords()`, to get the source:
   *   - for data source which comes from an array directly, please use `getSourceRecords()`,
   *   - for data source which comes from AGOL/portal item or a remote database:
   *     - for queriable data source, please use `query()` or `load()`,
   *     - for stream data source, please use `onData` (TBD).
   */
  updateRecords: (records: DataRecord[]) => Promise<boolean>
  addRecord: (record: DataRecord) => Promise<DataRecord>
  updateRecord: (record: DataRecord) => Promise<boolean>
  deleteRecord: (index: number) => Promise<boolean>
  deleteRecordById: (id: string) => Promise<boolean>
  // #endregion

  // #region interface after editing source data of data source (**the edit operation isn't done by data source**, e.g. via ArcGIS REST API directly)
  /**
   * @ignore
   * These methods are used to update records in data source after editing data out of data source (**the edit operation isn't done by data source**).

   * No need to use these methods if the edit operation is done by data source.
   */
  afterUpdateRecords: (records: DataRecord[]) => void
  afterAddRecord: (record: DataRecord) => void
  afterUpdateRecord: (record: DataRecord) => void
  afterDeleteRecordById: (id: string) => void
  // #endregion

  // #region interface for data source selection
  /**
   * Data source may have selected data, use selection view to handle it.
   *
   *  - All user selected records will be saved in `sourceRecords` of selection view,
   *  - `records` of selection view are updated automatically whenever `sourceRecords` or filter of selection view changes,
   *  - `selectedIds` of data source info is the real hightlighted records of the data source,
   *    both of main data source and data views have their own info, `selectedIds` of data view info is subset of `selectedIds` of main data source info since some selected records of main data source may do not match filter of data view,
   *
   *  - If widget add a filter to selection view,
   *     - `sourceRecords` of selection view will still be the same,
   *     - `records` of selection view and `selectedIds` of main data source and all derived data sources will be the filtered result,
   *  - If widget add a filter to main data source/data view,
   *     - if load data, `sourceRecords` and `records` will be added missing ones, if don't load data, they will keep the same,
   *     - if load data, `selectedIds` of the filtered data source and data sources which are derived from it will be the filtered result, if don't load data, they will keep the same,
   *
   *  - If query or load selection view, the view will load ArcGIS JS API and then will create a client-side feature layer to do query,
   *  - If open no_selection view and `sourceRecords` of selection view is empty, will use `records` of no_selection view as `sourceRecords` of selection view,
   *  - `records` of no_selection view are updated automatically, too.
   *  - No_selection view only loads one page, won't use all records of no_selection view as default value of selection view.
   */
  /**
   * @ignore
   * Select record by index.
   */
  selectRecord?: (index: number) => void
  /**
   * @ignore
   * Select record by indices.
   */
  selectRecords?: (indexes: number[]) => void
  /**
   * Select a record by ID.
   * When select record by ID, we can pass in the record. So when the selected record is not loaded, we can add it in.
   * If `forceCheck` is true, will check whether the record match filters of the data source or not. Will select the record only if the check is passed.
   *
   * @param id The ID to be selected. The selection will be cleared if the ID is null.
   */
  selectRecordById?: (id: string, record?: DataRecord, forceCheck?: boolean) => void
  /**
   * Select records by IDs.
   * When select records by IDs, we can pass in the records. So when the selected records are not loaded, we can add them in.
   * If `forceCheck` is true, will check whether these records match filters of the data source or not. Will select the records which check is passed.
   *
   * @param ids The IDs to be selected. The selection will be cleared if the IDs are null.
   */
  selectRecordsByIds?: (ids: string[], records?: DataRecord[], forceCheck?: boolean) => void
  /** Get selected records */
  getSelectedRecords?: () => DataRecord[]
  /** Get selected record indexes*/
  getSelectedRecordIndexes?: () => number[]
  /** Get selected record IDs*/
  getSelectedRecordIds?: () => string[]
  getSelectedRecordIdsFromInfo: () => ImmutableArray<string>
  /**
   * Update selected record IDs in data source info if the current data source listens selection change (see `setListenSelection`) or the current data source is the trigger data source (that is to say, select via it).
   *
   * Before update info, will check whether these selected records match filters of the current data source firstly, and then only set the matched selected records to info.
   * Will skip the check in some cases to improve performance if the `forceCheck` is not passed in or is false. For example, if the curren data source is main data source (we suppose that main data source contains all records, no need to check).
   * But if the `forceCheck` is true, won't skip the check.
   */
  updateSelectionInfo?: (ids: string[], triggerDataSource: DataSource, forceCheck?: boolean) => void
  clearSelection?: () => void

  /**
    * Whether listen selected records from other data sources which are derived from the same main data source.
    * If true, will update selected record IDs of current data source info when selecting records via other derived data sources. Will also update selected record IDs when selecting records via current data source itself.
    * If false, won't change selected record IDs when selecting records via other derived data sources. Will update selected record IDs only when selecting records via current data source itself.
    *
    * Main data source and its data views will listen selected records by default, local data source does not listen selected records by default.
    */
  setListenSelection: (listen: boolean) => void
  /** Return whether listen selection. */
  getListenSelection: () => boolean
  /**
    * If selected records are not loaded in the current data source, they will be concatenated to the end of records array.
    * For example, record 1 is selected in data view 1 and it is not loaded in data view 2 (record 1 actually matches query params of data view 2),
    *      dataView2.getRecordsWithSelection() will return all loaded records in data view 2 and record 1.
    */
  getRecordsWithSelection: () => DataRecord[]
  // #endregion
}

/**
 * `QueriableDataSource` extends `DataSource` and add query capability. A queriable data source must
 * have an `URL` to execute the query.
 *
 * The current default query implementation supports pagination. It allows mulitple widgets to apply queries on the same data source,
 * all of which are merged by using the `AND` logic operator.
 *
 * When execute a query, in addition to the passed in query parameters, all configured queries and
 * all other widgets applied queries are merged by using the `AND` logic operator.
 *
 * When a query is executed against a data view, the query from its main data source is used as well.
 */
export interface QueriableDataSource extends DataSource {
  /** The data source URL */
  url: string
  lastUpdateTime: Date
  /**
   * Whether the data source is case-sensitive.
   */
  isCaseSensitive: boolean

  /**
   * Execute the query against the service and update the internal data records, pagination is supported.
   * When call this method, the real query is returnd by `getRealQueryParams`.
   *
   * Pagination:
   * The pagination properties in the passed in query parameter may be not the same as the real query pagination that is sent to the service.
   * The real query pagination is defined in the data source setting.
   */
  load: (query: QueryParams, options?: QueryOptions) => Promise<DataRecord[]>

  /**
   * Load record by ID, do not consider other queries.
   */
  loadById: (id: string, refresh?: boolean) => Promise<DataRecord>

  /** Load the records count. */
  loadCount: (query: QueryParams, options?: QueryOptions) => Promise<number>

  /**
   * Update the data source query without executing the actual query.
   */
  updateQueryParams: (query: QueryParams, widgetId: string) => void

  /**
   * Get the current query parameters. The current query parameters contain all applied queries.
   */
  getCurrentQueryParams: (options?: GetCurrentQueryParamsOptions) => QueryParams
  getCurrentQueryId: () => string

  /** Get the queries applied in runtime. If the excludeWidgetId is passed in, the queries of this widget will be excluded. */
  getRuntimeQueryParams: (excludeWidgetId?: string) => QueryParams
  /**
   * Get the user config query parameters.
   */
  getConfigQueryParams: () => QueryParams

  /** Get the query parameters configured in remote (not in exb). */
  getRemoteQueryParams: () => QueryParams

  /**
   * Merge queries by using `AND`, and return the merged result.
   * If any query is undefined/null, it will be ignored.
   */
  mergeQueryParams: (...queries: QueryParams[]) => QueryParams

  /**
   * When do query/load, we do not fire the query request directly. Instead, we'll consider the data source's config/current query parameter.
   *  * For load: we'll merge the configured query parameter if it has, and all widget applied queries.
   *  * For query, we'll merge the current query parameter and the configured query parameter it has.
   */
  getRealQueryParams: (query: QueryParams, flag: 'query' | 'load', options?: QueryOptions) => QueryParams

  /**
   * Execute query against the service only, do NOT update the internal data records.
   * The actural query parameters are generated by `getRealQueryParams`.
   *
   * To query count, please use `queryCount`.
   */
  query: (query: QueryParams, options?: QueryOptions) => Promise<QueryResult>

  /** Query record by ID */
  queryById: (id: string) => Promise<DataRecord>

  /** Query count */
  queryCount: (query: QueryParams, options?: QueryOptions) => Promise<QueryResult>

  /**
   * The page size here defines the records this method returns, which are not the actual query pageSize. Will use a fixed pageSize to query and cache data.
   */
  getRecordsByPage: (page: number, pageSize: number) => DataRecord[]

  getPagesData: () => { [page: number]: DataRecord[] }
  setPagesData: (pages: { [page: number]: DataRecord[] }) => void

  /**
   * Get real query page depends on the widget's request page.
   */
  getRealQueryPages: (pageSize: number, page: number) => number[]

  getQueryPageSize: () => number

  /**
   * Null means there is no record count limit, and will return all records from the service.
   */
  getMaxRecordCount: () => number

  // TODO add/update/delete multiple records
  /** @ignore */
  getSaveStatus: () => DataSourceStatus
  /** @ignore */
  setSaveStatus?: (status: DataSourceStatus) => void

  /** Override parent interface to get correct type. */
  getDataViews: () => QueriableDataSource[]
  getDataView: (dataViewId: string) => QueriableDataSource
  getMainDataSource: () => QueriableDataSource

  /** If the return value > 0, auto refresh is enabled. */
  getAutoRefreshInterval: () => number
  getLastRefreshTime: () => Date
  startAutoRefresh: () => void
  stopAutoRefresh: () => void
  allowToExportData: () => Promise<boolean>

  /**
  * If selected records are not loaded in the current data source, will concat them to the end of records array.
  * See {@link getRecordsWithSelection} for details.
  */
  getRecordsByPageWithSelection: (page: number, pageSize: number) => DataRecord[]
}

/** @ignore */
export interface LoadableDataSource extends DataSource {
  url: string

  /**
   * Load all data records.
   */
  load: () => Promise<DataRecord[]>
}

export interface SimpleLocalDataSource extends DataSource {
  type: DataSourceTypes.SimpleLocal
}

export interface CsvDataSource extends LoadableDataSource {
  type: DataSourceTypes.CSV
  doLoad: () => Promise<DataRecord[]>
}

/**
 * `FeatureLayerDataSource` is created from a single feature layer of feature service, map service or webmap/webscene.
 */
export interface FeatureLayerDataSource extends QueriableDataSource, ItemMixin {
  type: DataSourceTypes.FeatureLayer
  url: string
  portalUrl?: string
  itemId?: string
  layerId?: string
  /**
   * The ArcGIS JS API [FeatureLayer](https://developers.arcgis.com/javascript/latest/api-reference/esri-layers-FeatureLayer.html) object.
   */
  layer?: __esri.FeatureLayer
  /**
   * The [Feature Layer](https://developers.arcgis.com/web-map-specification/objects/featureLayer/) JSON object.
   */
  restLayer?: IFeatureLayer
  /** Return the current GDB version. */
  getGDBVersion: () => string
  /** Change the layer GDB version. */
  changeGDBVersion: (gdbVersion: string) => void
  createJSAPILayerByDataSource: () => Promise<__esri.FeatureLayer>
  createRestAPILayerByDataSource: () => IFeatureLayer
  setAssociatedDataSource: (associatedDataSource: SceneLayerDataSource) => void
  getAssociatedDataSource: () => SceneLayerDataSource
  getCharts: () => WebMapWebChart[]
  supportSymbol: () => boolean
  supportAttachment: () => boolean
  setLayerDefinition: (layerDefinition: ILayerDefinition) => void
  getLayerDefinition: () => ILayerDefinition
  setPopupInfo: (popupInfo: IPopupInfo) => void
  getPopupInfo: () => IPopupInfo
  /**
   * @ignore
   * To do query based on query capabilities of the feature layer, we do two things.
   * 1. Before doing query, we fix query object by removing some conflicts params, see `fixQueryParam`.
   * 2. When doing query, we send query request by query capabilities (may remove some params), then enhance the result (using the removed params), see `doQuery`.
   */
  getCapabilities: () => FeatureLayerCapabilities
  supportTime: () => boolean
  getTimeInfo: () => TimeInfo

  // #region Overrides for parent interface
  load: (query: FeatureLayerQueryParams, options?: QueryOptions) => Promise<DataRecord[]>
  loadCount: (query: FeatureLayerQueryParams, options?: QueryOptions) => Promise<number>
  query: (queryProperties: FeatureLayerQueryParams) => Promise<QueryResult>
  queryCount: (queryProperties: FeatureLayerQueryParams) => Promise<QueryResult>
  queryById: (id: string) => Promise<FeatureDataRecord>
  selectRecordById: (id: string, record?: FeatureDataRecord, forceCheck?: boolean) => void
  selectRecordsByIds: (ids: string[], records?: FeatureDataRecord[], forceCheck?: boolean) => void
  getIdField: () => string
  getGeometryType: () => GeometryType
  getConfigQueryParams: () => FeatureLayerQueryParams
  mergeQueryParams: (...queries: FeatureLayerQueryParams[]) => FeatureLayerQueryParams
  getRealQueryParams: (query, flag: 'query' | 'load', options?: QueryOptions) => FeatureLayerQueryParams
  getCurrentQueryParams: (options?: GetCurrentQueryParamsOptions) => FeatureLayerQueryParams
  fetchSchema: () => Promise<IMDataSourceSchema>
  getFieldCodedValueList: (jimuFieldName: string, record?: FeatureDataRecord) => CodedValue[]
  buildRecord: (feature: IFeature | __esri.Graphic) => FeatureDataRecord
  // #endregion
}

/**
 * Layer from ArcGIS JS API, which may contain sublayers.
 */
export type ArcGISFolderLayer = __esri.MapImageLayer | __esri.TileLayer | __esri.GroupLayer | __esri.Sublayer

/**
 * There is no actual ArcGIS "LayerFolder" service, this interface defines the common behavior of these service:
 *  MapService, FeatureService, SceneService, and GroupLayerService
 */
export interface AbstractArcGISLayerFolderDataSource extends DataSource, ItemMixin {
  getServiceDefinition: () => ServiceDefinition

  /** Get the service GDB version. */
  getGDBVersion: () => string
  /** Change the GDB version for all layers in the service. */
  changeGDBVersion: (gdbVersion: string) => void
}

/**
 * `GroupLayerDataSource` is created from a group layer of map service or webmap/webscene.
 */
export interface GroupLayerDataSource extends AbstractArcGISLayerFolderDataSource {
  type: DataSourceTypes.GroupLayer
  /**
   * When add a map service directly, there is no layer instance created.
   * When add a webmap that contains map service, the folder in the map service will be created as `__esri.Sublayer` layer.
   * When add a webmap that contains group layer created in MapViewer, the group will be created as `__esri.GroupLayer` layer.
   */
  layer?: __esri.GroupLayer | __esri.Sublayer
}

/**
 * `FeatureServiceDataSource` is created from feature service.
 */
export interface FeatureServiceDataSource extends AbstractArcGISLayerFolderDataSource {
  type: DataSourceTypes.FeatureService

  /**
   * When add a FeatuerService into a webmap, the MapViewer does not create FeatuerService layer, instead it'll create multiple FeatureLayers.
   * So, the `FeatureServiceDataSource` does not have `layer` property.
   */
}

/**
 * `MapServiceDataSource` is created from map service or webmap/webscene.
 */
export interface MapServiceDataSource extends AbstractArcGISLayerFolderDataSource {
  type: DataSourceTypes.MapService
  /**
   * When add a map service directly, there is no layer instance created.
   * When add a webmap that contains map service, the map service will be created as `__esri.MapImageLayer` or `__esri.TileLayer` layer.
   */
  layer?: __esri.MapImageLayer | __esri.TileLayer
  supportTime: () => boolean
  getTimeInfo: () => TimeInfo
  /** Get the time extent. */
  getTimeExtent: () => TimeExtent
  /** Change the time extent for all layers in the service. */
  changeTimeExtent: (time: TimeExtent, widgetId: string) => void
}

/**
 * `SceneServiceDataSource` is created from scene service or webscene.
 */
export interface SceneServiceDataSource extends AbstractArcGISLayerFolderDataSource {
  type: DataSourceTypes.SceneService

  /**
   * When add a SceneService into a webscene, the SceneViewer does not create SceneService layer, instead it'll create it as a a group layer.
   * So, the `SceneServiceDataSource` does not have `layer` property.
   */
}

/**
 * `SceneLayerDataSource` is created from a single scene layer of scene service or webscene.
 */
export interface SceneLayerDataSource extends QueriableDataSource, ItemMixin {
  type: DataSourceTypes.SceneLayer
  layer?: __esri.SceneLayer
  url: string
  portalUrl?: string
  itemId?: string
  layerId?: string
  createJSAPILayerByDataSource: () => Promise<__esri.SceneLayer>
  getAssociatedDataSource: () => FeatureLayerDataSource
  setLayerDefinition: (layerDefinition: ILayerDefinition) => void
  getLayerDefinition: () => ILayerDefinition
  setPopupInfo: (popupInfo: IPopupInfo) => void
  getPopupInfo: () => IPopupInfo
  /** Return the current GDB version. */
  getGDBVersion: () => string
  /** Change the layer GDB version. */
  changeGDBVersion: (gdbVersion: string) => void
  supportSymbol: () => boolean
  supportAttachment: () => boolean
  // #region Overrides for parent interface
  load: (query: FeatureLayerQueryParams, options?: QueryOptions) => Promise<DataRecord[]>
  loadCount: (query: FeatureLayerQueryParams, options?: QueryOptions) => Promise<number>
  query: (queryProperties: FeatureLayerQueryParams) => Promise<QueryResult>
  queryCount: (queryProperties: FeatureLayerQueryParams) => Promise<QueryResult>
  queryById: (id: string) => Promise<FeatureDataRecord>
  selectRecordById: (id: string, record?: FeatureDataRecord, forceCheck?: boolean) => void
  selectRecordsByIds: (ids: string[], records?: FeatureDataRecord[], forceCheck?: boolean) => void
  getIdField: () => string
  getGeometryType: () => GeometryType
  getConfigQueryParams: () => FeatureLayerQueryParams
  mergeQueryParams: (...queries: FeatureLayerQueryParams[]) => FeatureLayerQueryParams
  getRealQueryParams: (query, flag: 'query' | 'load', options?: QueryOptions) => FeatureLayerQueryParams
  getCurrentQueryParams: (options?: GetCurrentQueryParamsOptions) => FeatureLayerQueryParams
  fetchSchema: () => Promise<IMDataSourceSchema>
  getFieldCodedValueList: (jimuFieldName: string, record?: FeatureDataRecord) => CodedValue[]
  buildRecord: (feature: IFeature | __esri.Graphic) => FeatureDataRecord
  // #endregion
}

/**
 * @ignore
 * @deprecated
 */
export interface FeatureQueryDataSource extends FeatureLayerDataSource { }

// #endregion Data sources

// #region Data capabilities

export interface FeatureLayerCapabilities {
  getQueryCapabilities: () => FeatureLayerQueryCapabilities
  // TODO: edit, attachment, operation, queryRelated and so on.
}

/**
 * @ignore
 */
export interface FeatureLayerQueryCapabilities {
  supportsStatistics: boolean
  supportsPagination: boolean
  supportsOrderBy: boolean
  supportsDistinct: boolean
  // map from supportsPaginationOnAggregatedQueries, undefined will be regarded as true since some services do not have this capability but support to use pagination with distinct
  supportsPaginationOnDistinct: boolean
  // map from supportsPaginationOnAggregatedQueries, undefined will be regarded as false
  supportsPaginationOnStatisticsWithGroupBy: boolean
  // if true, can not use out statistic fields as order by fields
  supportsOrderByOnlyOnLayerFields: boolean
  // supports percentile as a statisticType when using outStatistics
  supportsPercentileStatistics: boolean
  supportedQueryFormats: string
}

// #endregion Data capabilities

// #region Item mixin

export interface ItemMixin {
  itemId?: string
  portalUrl?: string
  getItemInfo: () => IItem
  getItemData: () => any
  fetchItemInfo: () => Promise<IItem>
  fetchItemData: () => Promise<any>
}

// #endregion Item mixin
